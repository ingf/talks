<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">

        <title>React Tutorial</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/mark.css" id="theme">

        <!-- Code syntax highlighting -->
        <link rel="stylesheet" href="lib/css/pojoaque.css">


        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <style>
        .reveal .slides section .fragment {
            text-align: left;
            padding: 10px 0 10px 15%;
        }

  </style>
    </head>

    <body>

        <div class="reveal">
            <div class="slides">

                <section data-markdown>
                    <script type="text/template">
                        # React Tutorial

                        <small style="margin-top:27px;line-height:1.3em;">
                            <a href="#/1">尹锋@wepiao</a>
                            <br/>Dec 2015
                        </small>
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <img src="attach/inf.jpeg" class="inf" style="width:200px"/>
                        ```
                        export default () => (
                            <Inf name="尹锋">
                                <Wepiao> Frontend Infrastructure Team @2015 </Wepiao>
                                <QFPay> 喵喵微店 HTML5 Team @2014 </QFPay>
                                <IQiYi> Mobile HTML5 Team @2011 </IQiYi>
                            </Inf>
                        )
                        ```
                        <small>
                            <a href="http://ingf.github.io/">Blog</a> /
                            <a href="https://github.com/ingf">GitHub</a> 
                        </small>
                    </script>
                </section>

                <section >
                    <h2>为什么是 React</h2>
                </section>

                <section >
                    <div class="fragment ">
                        用于构建用户界面的 JavaScript 库
                    </div>
                    <div class="fragment ">
                        源自 Facebook
                    </div>
                </section>

                <section >
                    <h2>React 能做什么</h2>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <div class="fragment">
                            Web: [https://facebook.github.io/react/](https://facebook.github.io/react/)
                        </div>
                        <div class="fragment">
                            Native: [https://facebook.github.io/react-native/](https://facebook.github.io/react-native/)
                        </div>
                        <div class="fragment">
                            TV: [https://github.com/jordanbyron/react-native/tree/tvOS](https://github.com/jordanbyron/react-native/tree/tvOS)
                        </div>
                        <div class="fragment">
                            Desktop: [https://github.com/ptmt/react-native-desktop](https://github.com/ptmt/react-native-desktop)
                        </div>
                        <div class="fragment">
                            ...
                        </div>
                    </script>
                </section>

                <section>
                    <h2 class="">
                        learn once, write anywhere
                    </h2>
                </section>

                <section data-markdown data-background="attach/taobao.png">
                </section>

                <section >
                    <h2>为什么是 Facebook</h2>
                </section>

                <section>
                    <h2>运行时间长，维护的工程师换了一批又一批</h2>
                    <aside class="notes">
                        我们先看一下大部分公司普遍存在的情况，几乎每个大一点的公司都有一个“运行时间长，维护的工程师换了一批又一批”的项目。
                    </aside>
                </section>

                <section>
                    <h2>Climb The Shit Mountain</h2>
                    <aside class="notes">
                        Amazon 曾经有个工程师描述维护这种项目的感觉：“climb the shit mountain”。
                    </aside>
                </section>

                <section>
                    <h2>Move Fast</h2>
                </section>

                <section >
                    <h2>菜鸟养成营</h2>
                    <aside class="notes">
                        Facebook 很希望工程师在第一天就把所有的编程环境都设置好，在第一天就提交代码。这样可以在周二参与每周例行的代码发布活动，将代码同步到 Facebook 几十万台服务器中。Facebook 并不希望新人在第一天提交复杂的代码，基本都是很简单的改变；希望通过练手让工程师能迅速了解整个流程，迅速进入角色。
                    </aside>
                </section>

                <section>
                    <div class="fragment">
                        新兵蛋子，上前线改 Bug，开发新 Feature
                    </div>
                    <div class="fragment">
                        前端代码不会随着时间消逝而快速腐烂
                    </div>
                    <aside class="notes">
                        React 的项目经理 Tom Occhino在 [F8](https://www.youtube.com/watch?v=nYkdrAPrdcw)表示，他们遇到了一些类似的问题
                        如何能让一帮刚从大学毕业的新兵蛋子，就可以上前线 Bug，或者开发新的 Feature
                        如何保证 Facebook 的各种背景的牛逼闪闪的全栈工程师写出来的前端代码不会随着时间消逝而快速腐烂
                        这两点其实也是很多软件工程师所关注的，特别是在前端，近几年来，前端发展很快，都不用一年半就完全是另一个模样。React 号称能让新人第一天开始使用，就能开发新功能。那么他是怎么做到的呢？
                    </aside>
                </section>

                <section>
                    <h2>简单</h2>
                </section>

                <section>
                    <h2>用 JSX 语法取代 HTML 模板，在 JavaScript 里声明式地描述 UI</h2>
                    <aside class="notes">
                        首先，Facebook 创造 JSX 语法，取代了我们常用的模板引擎，允许我们可以直接在 js 文件中来使用 JSX，这种语法结合了 HTML 和 JavaScript 的优势，既能像平常一样使用 HTML，同时又能在 HTML 中使用强大的 JavaScript 语言。相当于我们可以把 View 和 JavaScript 逻辑写在同一个文件里面。
                    </aside>
                </section>

                <section>
                    <h2>虚拟 DOM 取代物理 DOM 作为操作对象</h2>
                    <h2>封装了 DOM 的事件系统</h2>
                    <aside class="notes">
                         说道 DOM，这中间话题比较多，在很久以前，因为浏览器厂商很多，而他们中间又有一些比较特立独行，所以开发者体验并不是很好，这时候 jQuery 站出来了。他在 DOM 之上做了一层封装，开发者调用 jQuery 的方法就好了。但是 Facebook 认为开发者直接操作 DOM 还不够好，所以他们搞了一个虚拟 DOM，开发者现在连 DOM 都不用操作了，它用一种更快的内置仿造的 DOM 来计算差异，为你计算出效率最高的 DOM 改变，然后自动去更新 DOM。而且还封装了事件系统，React 的高明之处就是这个事件系统对于开发者而言，并没有新的接口或者其他，一看就会，比 jQuery 还简单。
                    </aside>
                </section>

                <section>
                    <h2>单向数据流动</h2>
                </section>

                <section>
                    <h2>组件和基于组件的设计流程</h2>
                </section>

                <section> 
                    <h2>ReactDOM.render()</h2>
                    <aside class="notes">
                        ReactDOM.render 是 React 的最基本方法，用于将组件转换成 HTML 语言，并插入指定的 DOM 节点。DEMO
                    </aside>
                </section>

                <section> 
                    <h2>JSX 语法</h2>
                    <div class="fragment">HTML 标签（以 '&lt;' 开头） ➜ HTML</div>
                    <div class="fragment">JS 代码块（以 '{' 开头） ➜  JavaScript</div>
                    <aside class="notes">
                        上一节的代码， HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法， 它允许 HTML 与 JavaScript 的混写。上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。由于可以写在一起，所以 JSX 语法功能特别强大，DEMO
                    </aside>
                </section>

                <section> 
                    <h2>组件</h2>
                    <div class="fragment"> 所谓组件，就是状态机器。</div>
                    <div class="fragment"> React 将用户界面看做简单的状态机器。</div>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ```
                            var id = 8888;

                            var Details = React.createClass({
                                render: function() {
                                    return (
                                        <div>
                                            this is detail page for {this.props.movieId}
                                        </div>
                                    )
                                }
                            });
                            
                            ReactDOM.render(
                                <Details movieId={movieId}></Details>,
                                document.getElementById('app')
                            );
                        ```
                    </script>
                    <aside class="notes">
                        上面代码中，我们把电影详情封装成一个组件 Details，然后就想插入普通 HTML 标签一样，在网页中插入这个组件。组件的用法和 HTML 标签完全一致，可以加入任意属性，比如我们给 Details 组件加入一个 movieId 属性，他的值为 id，这个值可以在组件内从 this.props 对象上面读取。
                    </aside>
                </section>

                <section> 
                    <h2>render: function() { }</h2>
                    <div class="fragment">
                        pure function
                    </div>
                    <aside class="notes">
                        所有的组件都必须实现 render 方法，我们先回顾一下模板引擎，基本都是返回字符串，然后在数据编进去，替换掉里面的变量，然后在把这段 HTML 片段 append 到 document 中。而 React 的 render 方法不是返回字符串， 是返回 view 的描述，是一颗 React 组件树，这棵树最终将会渲染成 HTML，render 方法是一个 pure function，就是说只负责纯粹的渲染逻辑，不涉及具体的业务逻辑和其他其他事情，这样可以使服务器端渲染更加切实可行，也使组件更容易被理解。

                    </aside>
                </section>

                <section> 
                    <h2>获取真实的DOM节点</h2>
                    <div class="fragment">
                        组件并不是真实的 DOM 节点
                    </div>

                    <div class="fragment">
                        this.refs.[refName]
                    </div>
                    <aside class="notes">
                        组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。
                    </aside>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ```
                        var Greeting = React.createClass({
                            handleClick: function() {
                                alert('Greeting, ' + this.refs.username.value);
                            },
                            render: function() {
                                return (
                                    <div>
                                        <input type="text" ref="username" />
                                        <input type="button" value="submit" onClick={this.handleClick} />
                                    </div>
                                );
                            }
                        });
                        ```
                    </script>
                    <aside class="notes">
                        上面代码中，组件 Greeting 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。

                    </aside>
                </section>

                <section data-markdown> 
                    <script type="text/template">
                        <h2>onClick={ }</h2>
                        <div class="fragment">
                        Click, KeyDown, Copy, Change, [all](http://facebook.github.io/react/docs/events.html#supported-events)
                        </div>
                    </script>
                    <aside class="notes">
                        上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll、Change、Input 等，完整的事件清单请查看官方文档。
                        React 里只需把事件处理器（event handler）以骆峰命名（camelCased）形式当作组件的 props 传入即可，就像使用普通 HTML 那样。React 内部创建一套合成事件系统来使所有事件在 IE8 和以上浏览器表现一致。也就是说，React 知道如何冒泡和捕获事件，而且你的事件处理器接收到的 events 参数与 [W3C]规范一致，无论你使用哪种浏览器。其实，当 React 启动的时候，它在最外层使用唯一一个事件监听器处理所有事件。当组件被加载和卸载时，只是在内部映射里添加或删除事件处理器。当事件触发，React 根据映射来决定如何分发。
                    </aside>
                </section>

                <section> 
                    <h2>this.state</h2>
                    <div class="fragment">
                        this.setState()
                    </div>
                    <aside class="notes">
                        React 把用户界面当作简单状态机。把用户界面想像成拥有不同状态然后渲染这些状态，可以轻松让用户界面和状态保持一致。React 里，只需调用 setState()来更新组件的 state，然后 React 根据新的 state 重新渲染用户界面（不要操作 DOM）。React 来决定如何最高效地更新 DOM。
                    </aside>
                </section>


                <section>
                    <h2>UI = &nbsp;&nbsp;&nbsp;&nbsp;f(state)</h2>
                </section>

                <section>
                    <h2>UI = render(state)</h2>
                    <aside class="notes">
                        在 React 中，我们只需要简单的去更新某个组件的状态，然后React 负责以最高效的方式去比较两个界面并更新 DOM 树，并输出基于新状态的整个界面。
                    </aside>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ```
                        var MovieList = React.createClass({
                            getInitialState: function() {
                                return {
                                    list: ['007：幽灵党','饥饿游戏3','我的少女时代']
                                };
                            },
                            componentDidMount: function() {
                                setTimeout(function () {
                                    this.setState({
                                        list: this.state.list.concat(['老炮儿','一切都好'])
                                    });
                                }.bind(this), 2000);
                            },
                            render: function() {
                                return (
                                    <div>
                                    {
                                        this.state.list.map(function (item, i) {
                                            return <div key={i}>{item}</div>
                                        })
                                    }
                                    </div>
                                )
                            }
                        });

                        ReactDOM.render(
                            <MovieList></MovieList>,
                            document.getElementById('app')
                        );
                        ```
                    </script>
                </section>

                <section>
                    <h2>
                        组件的详细说明和生命周期
                    </h2>
                    <div class="fragment">
                        Mounting：已插入真实 DOM 
                    </div>
                    <div class="fragment">
                        Updating：正在被重新渲染
                    </div>
                    <div class="fragment">
                        Unmounting：已移出真实 DOM
                    </div>
                    <aside class="notes">
                        React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。
                    </aside>
                </section>

                <section>
                    <div class="fragment">componentWillMount()</div>
                    <div class="fragment">componentDidMount()</div>
                    <div class="fragment">componentWillUpdate(object nextProps, object nextState)</div>
                    <div class="fragment">componentDidUpdate(object prevProps, object prevState)</div>
                    <div class="fragment">componentWillUnmount()</div>
                </section>

                <section data-background="attach/lifecycle.png">
                    <aside class="notes">
                        图中的方法几乎已经包括了 React 的所有 API，自定义组件时根据需要在组件生命周期的不同阶段实现不同的逻辑。除了必须实现 render 方法之外，其它常用的方法包括：- getDefaultProps: 在组件挂载之前调用一次。返回值将会作为 this.props 的初始值。- getInitialState: 在组件挂载之前调用一次。返回值将会作为 this.state的初始值。- componentDidMount: 在组件第一次render之后调用，这时组件对应的DOM节点已被加入到浏览器。在这个方法里可以去实现一些初始化逻辑。- componentWillUnmount: 在DOM节点移除之后被调用，这里可以做一些相关的清理工作。
                    </aside>
                </section>

                <section>
                    <h2>
                        组件化的开发思路
                    </h2>
                    <h3 class="fragment">UI</h3>
                    <h3 class="fragment">UI</h3>
                    <h3 class="fragment">重新思考 UI</h3>
                    <aside class="notes">
                        虚拟 DOM 不仅带来了简单的 UI 开发逻辑，同时也带来了组件化开发的思想，所谓组件，即封装起来的具有独立功能的 UI 部件。React 推荐以组件的方式去重新思考 UI 构成，将 UI 上每一个功能相对独立的模块定义成组件，然后将小的组件通过组合或者嵌套的方式构成大的组件，最终完成整体 UI 的构建。例如，Facebook 的 [Instagram](http://instagram.com/) 整站都采用了 React 来开发，整个页面就是一个大的组件，其中包含了嵌套的大量其它组件，大家有兴趣可以看下它背后的代码。
                    </aside>
                </section>

                <section>
                    <h2>
                        MVC
                    </h2>
                    <div class="fragment">技术  ➜  表现，数据，控制</div>
                    <h2>
                        React
                    </h2>
                    <div class="fragment"> 功能 ➜ UI </div>
                    <aside class="notes">
                        对于 MVC 开发模式来说，开发者将三者定义成不同的类，实现了表现，数据，控制的分离，开发者更多的是从技术的角度来进行拆分，实现松耦合。对于 React 而言，则完全是一个新的思路，开发者从功能的角度出发，将 UI 分成不同的组件，每个组件都独立封装。组件的封装方式和单向数据流动能够极大地简化前端架构的理解难度。下面我们通过组件化的思路来构建我们的电影详情页（为了 DEMO，请原谅我把产品原型修改的这么丑）。
                    </aside>
                </section>

                <section>
                    <img src="attach/detail.png" alt="" style="width: 65%"/>
                </section>

                <section>
                    <div class="fragment">- Details</div>
                    <div class="fragment">&emsp;- Header</div>
                    <div class="fragment">&emsp;- Story</div>
                    <div class="fragment">&emsp;- Poster</div>
                    <div class="fragment">&emsp;- CommentBox</div>
                    <div class="fragment">&emsp;&emsp;- CommentList</div>
                    <div class="fragment">&emsp;&emsp;- CommentForm</div>
                </section>

                <section>
                    <h2>
                        coding
                    </h2>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        <div class="fragment">可组合</div>
                        <div class="fragment">可重用</div>
                        <div class="fragment">可维护</div>
                        <div class="fragment">可测试</div>
                    </script>
                    <aside class="notes">
                        通过这种方式，每个组件的UI和逻辑都定义在组件内部，和外部完全通过 API 来交互，通过组合的方式来实现复杂的功能。React 认为一个组件应该具有如下特征：

                        可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的 UI 可以拆分成多个简单的 UI 组件；
                        可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景；
                        可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；
                        可测试（Testable）：因为每个组件都是独立的，那么对于各个组件分别测试显然要比对于整个 UI 进行测试容易的多。

                        React 是一个全新思路的前端 UI 框架，它完全接管了 UI 开发中最为复杂的局部更新部分，擅长在在复杂场景下保证高性能；同时，它引入了基于组件的开发思想，从另一个角度来重新审视 UI 的构成。通过这种方法，不仅能够提高开发效率，而且可以让代码更容易理解，维护和测试。
                    </aside>
                </section>
                
                <section>
                    <h1 style="font-size: 500px">?</h1>
                </section>
          
                <section>
                    <div class="fragment">高性能虚拟 DOM？</div>
                    <div class="fragment">JSX？</div>
                    <div class="fragment">封装过的事件机制？</div>
                    <div class="fragment">调试机制？</div>
                    <aside class="notes">
                        
                    </aside>
                </section>

                <section data-markdown>
                    <script type="text/template">
                    <h2>
                        声明式的，直观的编程方式
                    </h2>
                    </script>
                    <aside class="notes">
                        尽管这些都足以重要，但是 Tom Occhino 指出 React 最有价值的是声明式的，直观的编程方式。软件工程想来不提倡高深莫测的技巧、复杂的算法去编程，相反，如何写出可理解可阅读可预测可维护的代码才是质量和效率的关键。编写可预测，符合习惯的代码。所谓可预测（predictable），即容易理解的代码。我们上面已经说了很多了。
                    </aside>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        90 年代
                        ```
                        <input type="button" value="submit" onclick="alert('你点了我')" />
                        ```
                        <br/>
                        jQuery 
                        ```
                        // 模板
                        <input type="button" value="submit" id="foo">foo</input>

                        // JavaScript 逻辑
                        $('#foo').click(function(e) {alert('你点了我')});   
                        ```
                        <br/>
                        React
                        ```
                        <input type="button" value="submit" onClick={this.handleClick} />
                        ```
                    </script>
                    <aside class="notes">
                        Facebook 在刚刚推广 React 的时候，有很多人认为这是一个巨大的退步，回到90年代了，但是 React 发展到今天，我认为那些人应该改变了他们当初的想法。
                    </aside>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ```
                            <div id="Details">
                                <Header data={this.state.info}/>
                                <Story data={this.state.info.detail}/>
                                <Poster data={this.state.info.still_list}/>
                                <CommentBox />
                            </div>
                        ```
                    </script>
                </section>

                <section>
                    <h2>
                        Kiss
                    </h2>
                    <div class="fragment">
                        Keep it simple & stupid（大道至简）
                    </div>
                    <aside class="notes">
                        是不是很简单，返璞归真，任何以为了解过前端的同学都能看懂这段代码，同时也能写出这样的代码！UNIX 的发明者里奇设定了 UNIX 的设计原则为 Keep it simple & stupid（大道至简）。
                    </aside>
                </section>

                <section>
                    <h2>
                        将来
                    </h2>
                    <div class="fragment">
                        react-router    
                    </div>
                    <div class="fragment">
                        Redux    
                    </div>
                    <div class="fragment">
                        CSS in JS    
                    </div>
                    <div class="fragment">
                        Immutable-js
                    </div>
                    <div class="fragment">
                        Webpack
                    </div>
                    <aside class="notes">
                        至此，React 的基本点都讲完了，但是社区还有大量的知识点需要学习，比如react-router, react-hot-reload, Redux 或者 Flux 的 N 种实现，CSS in JS 及其 N 种实现，Immutable-js，webpack...
                        虽然有点多，但是每项都可以学出来装逼用，而且目前大家不用担心，因为大部分我们都已经打包到 [pepper](http://gitlab.intra.wepiao.com/FEI/pepper/tree/master) 里面了。在后面的分享里面我们会逐步深入进去，欢迎大家关注这个项目，有任何问题都可以在 gitlab 里面提 issue，然后欢迎所有同学都可以一起来分享在 React 上的一些事情。
                    </aside>
                </section>

                <section>
                    <h2>
                        Pepper
                    </h2>
                </section>
                <section data-markdown>
                    <script type="text/template">
                        # *Question*
                    </script>
                </section>
                
            </div>
        </div>

        <pre style="display:none"><code> force highlight.js work </code></pre>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,
                transition: 'none', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

        <script type="text/javascript">
            function codeEditor(){
                var nodes = document.querySelectorAll("code");
                for (var i = 0; i < nodes.length; i++) {
                    nodes[i].setAttribute("contenteditable", '');
                }
                console.log('code editable now.');
            }
            window.codeEditor = codeEditor;

            document.addEventListener('DOMContentLoaded', function(){
                setTimeout(function(){
                    codeEditor();
                },1000)
            })
        </script>
    </body>
</html>